// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trgt.proto

#include "trgt.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace tea {
namespace analysis {
PROTOBUF_CONSTEXPR DomInfo::DomInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DomInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DomInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DomInfoDefaultTypeInternal() {}
  union {
    DomInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DomInfoDefaultTypeInternal _DomInfo_default_instance_;
PROTOBUF_CONSTEXPR RelInfo::RelInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dom_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct RelInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RelInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RelInfoDefaultTypeInternal() {}
  union {
    RelInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RelInfoDefaultTypeInternal _RelInfo_default_instance_;
PROTOBUF_CONSTEXPR DomTrgt::DomTrgt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.location_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DomTrgtDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DomTrgtDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DomTrgtDefaultTypeInternal() {}
  union {
    DomTrgt _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DomTrgtDefaultTypeInternal _DomTrgt_default_instance_;
PROTOBUF_CONSTEXPR RelTrgt::RelTrgt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.location_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RelTrgtDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RelTrgtDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RelTrgtDefaultTypeInternal() {}
  union {
    RelTrgt _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RelTrgtDefaultTypeInternal _RelTrgt_default_instance_;
PROTOBUF_CONSTEXPR Tuple::Tuple(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.attribute_)*/{}
  , /*decltype(_impl_.rel_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TupleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TupleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TupleDefaultTypeInternal() {}
  union {
    Tuple _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TupleDefaultTypeInternal _Tuple_default_instance_;
PROTOBUF_CONSTEXPR Constraint::Constraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.body_tuple_)*/{}
  , /*decltype(_impl_.rule_info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.head_tuple_)*/nullptr} {}
struct ConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConstraintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConstraintDefaultTypeInternal() {}
  union {
    Constraint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConstraintDefaultTypeInternal _Constraint_default_instance_;
PROTOBUF_CONSTEXPR Provenance::Provenance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.constraint_)*/{}
  , /*decltype(_impl_.input_)*/{}
  , /*decltype(_impl_.output_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ProvenanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProvenanceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProvenanceDefaultTypeInternal() {}
  union {
    Provenance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProvenanceDefaultTypeInternal _Provenance_default_instance_;
}  // namespace analysis
}  // namespace tea
static ::_pb::Metadata file_level_metadata_trgt_2eproto[7];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_trgt_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_trgt_2eproto = nullptr;

const uint32_t TableStruct_trgt_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::tea::analysis::DomInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::DomInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tea::analysis::DomInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::DomInfo, _impl_.description_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::tea::analysis::RelInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::RelInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tea::analysis::RelInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::RelInfo, _impl_.dom_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::RelInfo, _impl_.description_),
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tea::analysis::DomTrgt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tea::analysis::DomTrgt, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::DomTrgt, _impl_.location_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tea::analysis::RelTrgt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tea::analysis::RelTrgt, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::RelTrgt, _impl_.location_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Tuple, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Tuple, _impl_.rel_name_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Tuple, _impl_.attribute_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Constraint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Constraint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Constraint, _impl_.head_tuple_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Constraint, _impl_.body_tuple_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Constraint, _impl_.rule_info_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Provenance, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Provenance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Provenance, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Provenance, _impl_.constraint_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Provenance, _impl_.input_),
  PROTOBUF_FIELD_OFFSET(::tea::analysis::Provenance, _impl_.output_),
  0,
  ~0u,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::tea::analysis::DomInfo)},
  { 10, 19, -1, sizeof(::tea::analysis::RelInfo)},
  { 22, -1, -1, sizeof(::tea::analysis::DomTrgt)},
  { 30, -1, -1, sizeof(::tea::analysis::RelTrgt)},
  { 38, -1, -1, sizeof(::tea::analysis::Tuple)},
  { 46, 55, -1, sizeof(::tea::analysis::Constraint)},
  { 58, 68, -1, sizeof(::tea::analysis::Provenance)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::tea::analysis::_DomInfo_default_instance_._instance,
  &::tea::analysis::_RelInfo_default_instance_._instance,
  &::tea::analysis::_DomTrgt_default_instance_._instance,
  &::tea::analysis::_RelTrgt_default_instance_._instance,
  &::tea::analysis::_Tuple_default_instance_._instance,
  &::tea::analysis::_Constraint_default_instance_._instance,
  &::tea::analysis::_Provenance_default_instance_._instance,
};

const char descriptor_table_protodef_trgt_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ntrgt.proto\022\014tea.analysis\"A\n\007DomInfo\022\014\n"
  "\004name\030\001 \001(\t\022\030\n\013description\030\002 \001(\tH\000\210\001\001B\016\n"
  "\014_description\"N\n\007RelInfo\022\014\n\004name\030\001 \001(\t\022\013"
  "\n\003dom\030\002 \003(\t\022\030\n\013description\030\003 \001(\tH\000\210\001\001B\016\n"
  "\014_description\"@\n\007DomTrgt\022#\n\004info\030\001 \001(\0132\025"
  ".tea.analysis.DomInfo\022\020\n\010location\030\002 \001(\t\""
  "@\n\007RelTrgt\022#\n\004info\030\001 \001(\0132\025.tea.analysis."
  "RelInfo\022\020\n\010location\030\002 \001(\t\",\n\005Tuple\022\020\n\010re"
  "l_name\030\001 \001(\t\022\021\n\tattribute\030\002 \003(\t\"\204\001\n\nCons"
  "traint\022\'\n\nhead_tuple\030\001 \001(\0132\023.tea.analysi"
  "s.Tuple\022\'\n\nbody_tuple\030\002 \003(\0132\023.tea.analys"
  "is.Tuple\022\026\n\trule_info\030\003 \001(\tH\000\210\001\001B\014\n\n_rul"
  "e_info\"\233\001\n\nProvenance\022\017\n\002id\030\001 \001(\tH\000\210\001\001\022,"
  "\n\nconstraint\030\002 \003(\0132\030.tea.analysis.Constr"
  "aint\022\"\n\005input\030\003 \003(\0132\023.tea.analysis.Tuple"
  "\022#\n\006output\030\004 \003(\0132\023.tea.analysis.TupleB\005\n"
  "\003_idB%\n#com.neuromancer42.tea.core.analy"
  "sisb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_trgt_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_trgt_2eproto = {
    false, false, 691, descriptor_table_protodef_trgt_2eproto,
    "trgt.proto",
    &descriptor_table_trgt_2eproto_once, nullptr, 0, 7,
    schemas, file_default_instances, TableStruct_trgt_2eproto::offsets,
    file_level_metadata_trgt_2eproto, file_level_enum_descriptors_trgt_2eproto,
    file_level_service_descriptors_trgt_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_trgt_2eproto_getter() {
  return &descriptor_table_trgt_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_trgt_2eproto(&descriptor_table_trgt_2eproto);
namespace tea {
namespace analysis {

// ===================================================================

class DomInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DomInfo>()._impl_._has_bits_);
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DomInfo::DomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tea.analysis.DomInfo)
}
DomInfo::DomInfo(const DomInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DomInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tea.analysis.DomInfo)
}

inline void DomInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DomInfo::~DomInfo() {
  // @@protoc_insertion_point(destructor:tea.analysis.DomInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DomInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
}

void DomInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DomInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:tea.analysis.DomInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.description_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DomInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.DomInfo.name"));
        } else
          goto handle_unusual;
        continue;
      // optional string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.DomInfo.description"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DomInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tea.analysis.DomInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.DomInfo.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string description = 2;
  if (_internal_has_description()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.DomInfo.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tea.analysis.DomInfo)
  return target;
}

size_t DomInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tea.analysis.DomInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // optional string description = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DomInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DomInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DomInfo::GetClassData() const { return &_class_data_; }


void DomInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DomInfo*>(&to_msg);
  auto& from = static_cast<const DomInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tea.analysis.DomInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_description()) {
    _this->_internal_set_description(from._internal_description());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DomInfo::CopyFrom(const DomInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tea.analysis.DomInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DomInfo::IsInitialized() const {
  return true;
}

void DomInfo::InternalSwap(DomInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DomInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trgt_2eproto_getter, &descriptor_table_trgt_2eproto_once,
      file_level_metadata_trgt_2eproto[0]);
}

// ===================================================================

class RelInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<RelInfo>()._impl_._has_bits_);
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RelInfo::RelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tea.analysis.RelInfo)
}
RelInfo::RelInfo(const RelInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RelInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dom_){from._impl_.dom_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tea.analysis.RelInfo)
}

inline void RelInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dom_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RelInfo::~RelInfo() {
  // @@protoc_insertion_point(destructor:tea.analysis.RelInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RelInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dom_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
}

void RelInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:tea.analysis.RelInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dom_.Clear();
  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.description_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RelInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.RelInfo.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated string dom = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_dom();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.RelInfo.dom"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.RelInfo.description"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RelInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tea.analysis.RelInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.RelInfo.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated string dom = 2;
  for (int i = 0, n = this->_internal_dom_size(); i < n; i++) {
    const auto& s = this->_internal_dom(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.RelInfo.dom");
    target = stream->WriteString(2, s, target);
  }

  // optional string description = 3;
  if (_internal_has_description()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.RelInfo.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tea.analysis.RelInfo)
  return target;
}

size_t RelInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tea.analysis.RelInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string dom = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.dom_.size());
  for (int i = 0, n = _impl_.dom_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.dom_.Get(i));
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // optional string description = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RelInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RelInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RelInfo::GetClassData() const { return &_class_data_; }


void RelInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RelInfo*>(&to_msg);
  auto& from = static_cast<const RelInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tea.analysis.RelInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dom_.MergeFrom(from._impl_.dom_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_description()) {
    _this->_internal_set_description(from._internal_description());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RelInfo::CopyFrom(const RelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tea.analysis.RelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RelInfo::IsInitialized() const {
  return true;
}

void RelInfo::InternalSwap(RelInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dom_.InternalSwap(&other->_impl_.dom_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RelInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trgt_2eproto_getter, &descriptor_table_trgt_2eproto_once,
      file_level_metadata_trgt_2eproto[1]);
}

// ===================================================================

class DomTrgt::_Internal {
 public:
  static const ::tea::analysis::DomInfo& info(const DomTrgt* msg);
};

const ::tea::analysis::DomInfo&
DomTrgt::_Internal::info(const DomTrgt* msg) {
  return *msg->_impl_.info_;
}
DomTrgt::DomTrgt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tea.analysis.DomTrgt)
}
DomTrgt::DomTrgt(const DomTrgt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DomTrgt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){}
    , decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_location().empty()) {
    _this->_impl_.location_.Set(from._internal_location(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::tea::analysis::DomInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:tea.analysis.DomTrgt)
}

inline void DomTrgt::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){}
    , decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DomTrgt::~DomTrgt() {
  // @@protoc_insertion_point(destructor:tea.analysis.DomTrgt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DomTrgt::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.location_.Destroy();
  if (this != internal_default_instance()) delete _impl_.info_;
}

void DomTrgt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DomTrgt::Clear() {
// @@protoc_insertion_point(message_clear_start:tea.analysis.DomTrgt)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.location_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DomTrgt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tea.analysis.DomInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string location = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.DomTrgt.location"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DomTrgt::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tea.analysis.DomTrgt)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tea.analysis.DomInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // string location = 2;
  if (!this->_internal_location().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_location().data(), static_cast<int>(this->_internal_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.DomTrgt.location");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_location(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tea.analysis.DomTrgt)
  return target;
}

size_t DomTrgt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tea.analysis.DomTrgt)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string location = 2;
  if (!this->_internal_location().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_location());
  }

  // .tea.analysis.DomInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DomTrgt::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DomTrgt::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DomTrgt::GetClassData() const { return &_class_data_; }


void DomTrgt::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DomTrgt*>(&to_msg);
  auto& from = static_cast<const DomTrgt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tea.analysis.DomTrgt)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_location().empty()) {
    _this->_internal_set_location(from._internal_location());
  }
  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::tea::analysis::DomInfo::MergeFrom(
        from._internal_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DomTrgt::CopyFrom(const DomTrgt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tea.analysis.DomTrgt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DomTrgt::IsInitialized() const {
  return true;
}

void DomTrgt::InternalSwap(DomTrgt* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.location_, lhs_arena,
      &other->_impl_.location_, rhs_arena
  );
  swap(_impl_.info_, other->_impl_.info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DomTrgt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trgt_2eproto_getter, &descriptor_table_trgt_2eproto_once,
      file_level_metadata_trgt_2eproto[2]);
}

// ===================================================================

class RelTrgt::_Internal {
 public:
  static const ::tea::analysis::RelInfo& info(const RelTrgt* msg);
};

const ::tea::analysis::RelInfo&
RelTrgt::_Internal::info(const RelTrgt* msg) {
  return *msg->_impl_.info_;
}
RelTrgt::RelTrgt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tea.analysis.RelTrgt)
}
RelTrgt::RelTrgt(const RelTrgt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RelTrgt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){}
    , decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_location().empty()) {
    _this->_impl_.location_.Set(from._internal_location(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::tea::analysis::RelInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:tea.analysis.RelTrgt)
}

inline void RelTrgt::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){}
    , decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RelTrgt::~RelTrgt() {
  // @@protoc_insertion_point(destructor:tea.analysis.RelTrgt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RelTrgt::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.location_.Destroy();
  if (this != internal_default_instance()) delete _impl_.info_;
}

void RelTrgt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RelTrgt::Clear() {
// @@protoc_insertion_point(message_clear_start:tea.analysis.RelTrgt)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.location_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RelTrgt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tea.analysis.RelInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string location = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.RelTrgt.location"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RelTrgt::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tea.analysis.RelTrgt)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tea.analysis.RelInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // string location = 2;
  if (!this->_internal_location().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_location().data(), static_cast<int>(this->_internal_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.RelTrgt.location");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_location(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tea.analysis.RelTrgt)
  return target;
}

size_t RelTrgt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tea.analysis.RelTrgt)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string location = 2;
  if (!this->_internal_location().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_location());
  }

  // .tea.analysis.RelInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RelTrgt::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RelTrgt::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RelTrgt::GetClassData() const { return &_class_data_; }


void RelTrgt::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RelTrgt*>(&to_msg);
  auto& from = static_cast<const RelTrgt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tea.analysis.RelTrgt)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_location().empty()) {
    _this->_internal_set_location(from._internal_location());
  }
  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::tea::analysis::RelInfo::MergeFrom(
        from._internal_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RelTrgt::CopyFrom(const RelTrgt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tea.analysis.RelTrgt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RelTrgt::IsInitialized() const {
  return true;
}

void RelTrgt::InternalSwap(RelTrgt* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.location_, lhs_arena,
      &other->_impl_.location_, rhs_arena
  );
  swap(_impl_.info_, other->_impl_.info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RelTrgt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trgt_2eproto_getter, &descriptor_table_trgt_2eproto_once,
      file_level_metadata_trgt_2eproto[3]);
}

// ===================================================================

class Tuple::_Internal {
 public:
};

Tuple::Tuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tea.analysis.Tuple)
}
Tuple::Tuple(const Tuple& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Tuple* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.attribute_){from._impl_.attribute_}
    , decltype(_impl_.rel_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.rel_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rel_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_rel_name().empty()) {
    _this->_impl_.rel_name_.Set(from._internal_rel_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tea.analysis.Tuple)
}

inline void Tuple::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.attribute_){arena}
    , decltype(_impl_.rel_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.rel_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rel_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Tuple::~Tuple() {
  // @@protoc_insertion_point(destructor:tea.analysis.Tuple)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tuple::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attribute_.~RepeatedPtrField();
  _impl_.rel_name_.Destroy();
}

void Tuple::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tuple::Clear() {
// @@protoc_insertion_point(message_clear_start:tea.analysis.Tuple)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attribute_.Clear();
  _impl_.rel_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tuple::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string rel_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_rel_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.Tuple.rel_name"));
        } else
          goto handle_unusual;
        continue;
      // repeated string attribute = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_attribute();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.Tuple.attribute"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Tuple::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tea.analysis.Tuple)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string rel_name = 1;
  if (!this->_internal_rel_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_rel_name().data(), static_cast<int>(this->_internal_rel_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.Tuple.rel_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_rel_name(), target);
  }

  // repeated string attribute = 2;
  for (int i = 0, n = this->_internal_attribute_size(); i < n; i++) {
    const auto& s = this->_internal_attribute(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.Tuple.attribute");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tea.analysis.Tuple)
  return target;
}

size_t Tuple::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tea.analysis.Tuple)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string attribute = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.attribute_.size());
  for (int i = 0, n = _impl_.attribute_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.attribute_.Get(i));
  }

  // string rel_name = 1;
  if (!this->_internal_rel_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_rel_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tuple::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tuple::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tuple::GetClassData() const { return &_class_data_; }


void Tuple::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tuple*>(&to_msg);
  auto& from = static_cast<const Tuple&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tea.analysis.Tuple)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attribute_.MergeFrom(from._impl_.attribute_);
  if (!from._internal_rel_name().empty()) {
    _this->_internal_set_rel_name(from._internal_rel_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tuple::CopyFrom(const Tuple& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tea.analysis.Tuple)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tuple::IsInitialized() const {
  return true;
}

void Tuple::InternalSwap(Tuple* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.attribute_.InternalSwap(&other->_impl_.attribute_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rel_name_, lhs_arena,
      &other->_impl_.rel_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Tuple::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trgt_2eproto_getter, &descriptor_table_trgt_2eproto_once,
      file_level_metadata_trgt_2eproto[4]);
}

// ===================================================================

class Constraint::_Internal {
 public:
  using HasBits = decltype(std::declval<Constraint>()._impl_._has_bits_);
  static const ::tea::analysis::Tuple& head_tuple(const Constraint* msg);
  static void set_has_rule_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::tea::analysis::Tuple&
Constraint::_Internal::head_tuple(const Constraint* msg) {
  return *msg->_impl_.head_tuple_;
}
Constraint::Constraint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tea.analysis.Constraint)
}
Constraint::Constraint(const Constraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Constraint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.body_tuple_){from._impl_.body_tuple_}
    , decltype(_impl_.rule_info_){}
    , decltype(_impl_.head_tuple_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.rule_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rule_info()) {
    _this->_impl_.rule_info_.Set(from._internal_rule_info(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_head_tuple()) {
    _this->_impl_.head_tuple_ = new ::tea::analysis::Tuple(*from._impl_.head_tuple_);
  }
  // @@protoc_insertion_point(copy_constructor:tea.analysis.Constraint)
}

inline void Constraint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.body_tuple_){arena}
    , decltype(_impl_.rule_info_){}
    , decltype(_impl_.head_tuple_){nullptr}
  };
  _impl_.rule_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Constraint::~Constraint() {
  // @@protoc_insertion_point(destructor:tea.analysis.Constraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Constraint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.body_tuple_.~RepeatedPtrField();
  _impl_.rule_info_.Destroy();
  if (this != internal_default_instance()) delete _impl_.head_tuple_;
}

void Constraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Constraint::Clear() {
// @@protoc_insertion_point(message_clear_start:tea.analysis.Constraint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.body_tuple_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.rule_info_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.head_tuple_ != nullptr) {
    delete _impl_.head_tuple_;
  }
  _impl_.head_tuple_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Constraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tea.analysis.Tuple head_tuple = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_head_tuple(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .tea.analysis.Tuple body_tuple = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_body_tuple(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string rule_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rule_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.Constraint.rule_info"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Constraint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tea.analysis.Constraint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tea.analysis.Tuple head_tuple = 1;
  if (this->_internal_has_head_tuple()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::head_tuple(this),
        _Internal::head_tuple(this).GetCachedSize(), target, stream);
  }

  // repeated .tea.analysis.Tuple body_tuple = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_body_tuple_size()); i < n; i++) {
    const auto& repfield = this->_internal_body_tuple(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string rule_info = 3;
  if (_internal_has_rule_info()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_rule_info().data(), static_cast<int>(this->_internal_rule_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.Constraint.rule_info");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_rule_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tea.analysis.Constraint)
  return target;
}

size_t Constraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tea.analysis.Constraint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tea.analysis.Tuple body_tuple = 2;
  total_size += 1UL * this->_internal_body_tuple_size();
  for (const auto& msg : this->_impl_.body_tuple_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string rule_info = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_rule_info());
  }

  // .tea.analysis.Tuple head_tuple = 1;
  if (this->_internal_has_head_tuple()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.head_tuple_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Constraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Constraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Constraint::GetClassData() const { return &_class_data_; }


void Constraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Constraint*>(&to_msg);
  auto& from = static_cast<const Constraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tea.analysis.Constraint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.body_tuple_.MergeFrom(from._impl_.body_tuple_);
  if (from._internal_has_rule_info()) {
    _this->_internal_set_rule_info(from._internal_rule_info());
  }
  if (from._internal_has_head_tuple()) {
    _this->_internal_mutable_head_tuple()->::tea::analysis::Tuple::MergeFrom(
        from._internal_head_tuple());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Constraint::CopyFrom(const Constraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tea.analysis.Constraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Constraint::IsInitialized() const {
  return true;
}

void Constraint::InternalSwap(Constraint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.body_tuple_.InternalSwap(&other->_impl_.body_tuple_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rule_info_, lhs_arena,
      &other->_impl_.rule_info_, rhs_arena
  );
  swap(_impl_.head_tuple_, other->_impl_.head_tuple_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Constraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trgt_2eproto_getter, &descriptor_table_trgt_2eproto_once,
      file_level_metadata_trgt_2eproto[5]);
}

// ===================================================================

class Provenance::_Internal {
 public:
  using HasBits = decltype(std::declval<Provenance>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Provenance::Provenance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tea.analysis.Provenance)
}
Provenance::Provenance(const Provenance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Provenance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.constraint_){from._impl_.constraint_}
    , decltype(_impl_.input_){from._impl_.input_}
    , decltype(_impl_.output_){from._impl_.output_}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tea.analysis.Provenance)
}

inline void Provenance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.constraint_){arena}
    , decltype(_impl_.input_){arena}
    , decltype(_impl_.output_){arena}
    , decltype(_impl_.id_){}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Provenance::~Provenance() {
  // @@protoc_insertion_point(destructor:tea.analysis.Provenance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Provenance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.constraint_.~RepeatedPtrField();
  _impl_.input_.~RepeatedPtrField();
  _impl_.output_.~RepeatedPtrField();
  _impl_.id_.Destroy();
}

void Provenance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Provenance::Clear() {
// @@protoc_insertion_point(message_clear_start:tea.analysis.Provenance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.constraint_.Clear();
  _impl_.input_.Clear();
  _impl_.output_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Provenance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tea.analysis.Provenance.id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .tea.analysis.Constraint constraint = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_constraint(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tea.analysis.Tuple input = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tea.analysis.Tuple output = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_output(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Provenance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tea.analysis.Provenance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string id = 1;
  if (_internal_has_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tea.analysis.Provenance.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // repeated .tea.analysis.Constraint constraint = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_constraint_size()); i < n; i++) {
    const auto& repfield = this->_internal_constraint(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .tea.analysis.Tuple input = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_input_size()); i < n; i++) {
    const auto& repfield = this->_internal_input(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .tea.analysis.Tuple output = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_output_size()); i < n; i++) {
    const auto& repfield = this->_internal_output(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tea.analysis.Provenance)
  return target;
}

size_t Provenance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tea.analysis.Provenance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tea.analysis.Constraint constraint = 2;
  total_size += 1UL * this->_internal_constraint_size();
  for (const auto& msg : this->_impl_.constraint_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tea.analysis.Tuple input = 3;
  total_size += 1UL * this->_internal_input_size();
  for (const auto& msg : this->_impl_.input_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tea.analysis.Tuple output = 4;
  total_size += 1UL * this->_internal_output_size();
  for (const auto& msg : this->_impl_.output_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Provenance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Provenance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Provenance::GetClassData() const { return &_class_data_; }


void Provenance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Provenance*>(&to_msg);
  auto& from = static_cast<const Provenance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tea.analysis.Provenance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.constraint_.MergeFrom(from._impl_.constraint_);
  _this->_impl_.input_.MergeFrom(from._impl_.input_);
  _this->_impl_.output_.MergeFrom(from._impl_.output_);
  if (from._internal_has_id()) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Provenance::CopyFrom(const Provenance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tea.analysis.Provenance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Provenance::IsInitialized() const {
  return true;
}

void Provenance::InternalSwap(Provenance* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.constraint_.InternalSwap(&other->_impl_.constraint_);
  _impl_.input_.InternalSwap(&other->_impl_.input_);
  _impl_.output_.InternalSwap(&other->_impl_.output_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Provenance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trgt_2eproto_getter, &descriptor_table_trgt_2eproto_once,
      file_level_metadata_trgt_2eproto[6]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace analysis
}  // namespace tea
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::tea::analysis::DomInfo*
Arena::CreateMaybeMessage< ::tea::analysis::DomInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tea::analysis::DomInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::tea::analysis::RelInfo*
Arena::CreateMaybeMessage< ::tea::analysis::RelInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tea::analysis::RelInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::tea::analysis::DomTrgt*
Arena::CreateMaybeMessage< ::tea::analysis::DomTrgt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tea::analysis::DomTrgt >(arena);
}
template<> PROTOBUF_NOINLINE ::tea::analysis::RelTrgt*
Arena::CreateMaybeMessage< ::tea::analysis::RelTrgt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tea::analysis::RelTrgt >(arena);
}
template<> PROTOBUF_NOINLINE ::tea::analysis::Tuple*
Arena::CreateMaybeMessage< ::tea::analysis::Tuple >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tea::analysis::Tuple >(arena);
}
template<> PROTOBUF_NOINLINE ::tea::analysis::Constraint*
Arena::CreateMaybeMessage< ::tea::analysis::Constraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tea::analysis::Constraint >(arena);
}
template<> PROTOBUF_NOINLINE ::tea::analysis::Provenance*
Arena::CreateMaybeMessage< ::tea::analysis::Provenance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tea::analysis::Provenance >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
